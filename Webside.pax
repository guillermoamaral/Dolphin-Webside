| package |
package := Package name: 'Webside'.
package paxVersion: 1;
	basicComment: ''.

package classNames
	add: #AddCategoryChange;
	add: #AddPackageChange;
	add: #ClassifyMethodChange;
	add: #CommentClassChange;
	add: #FakeListPresenter;
	add: #HttpRequestRouter;
	add: #MatchAlgorithm;
	add: #MatchToken;
	add: #PercentEncoder;
	add: #RefactoryCategoryChange;
	add: #RefactoryPackageChange;
	add: #RemoveCategoryChange;
	add: #RemovePackageChange;
	add: #RenameCategoryChange;
	add: #RenamePackageChange;
	add: #StarToken;
	add: #StringPattern;
	add: #URL;
	add: #URLTemplate;
	add: #URLTemplateTest;
	add: #URLTest;
	add: #WebsideAPI;
	add: #WebsideClient;
	add: #WebsideEvaluation;
	add: #WebsideException;
	add: #WebsideResource;
	add: #WebsideServer;
	add: #WebsideWorkspace;
	yourself.

package methodNames
	add: #AddClassChange -> #asWebsideJson;
	add: #AddClassChange -> #fromWebsideJson:;
	add: #AddClassChange -> #websideExecute;
	add: #AddMethodChange -> #asWebsideJson;
	add: #AddMethodChange -> #fromWebsideJson:;
	add: #Character -> #isAsterisk;
	add: #Character -> #isQuestionMark;
	add: #ClassDescription -> #asWebsideJson;
	add: #Collection -> #anyone;
	add: #Collection -> #gather:;
	add: #Collection -> #gather:in:;
	add: #Collection -> #groupBy:;
	add: #CompiledCode -> #asWebsideJson;
	add: #CompiledMethod -> #asWebsideJson;
	add: #CompilerNotification -> #asWebsideJson;
	add: #Debugger -> #adaptToWebside;
	add: #Debugger -> #process;
	add: #Debugger -> #stepInto:;
	add: #Debugger -> #stepIntoBlock:;
	add: #Debugger -> #stepOver:;
	add: #Exception -> #asWebsideJson;
	add: #MethodCompileFailed -> #asWebsideJson;
	add: #MethodRefactoring -> #asWebsideJson;
	add: #MethodRefactoring -> #fromWebsideJson:;
	add: #Object -> #asWebsideJson;
	add: #Object -> #websideIconName;
	add: #Object -> #websideViews;
	add: #Package -> #asWebsideJson;
	add: #PullUpInstanceVariableRefactoring -> #fromWebsideJson:;
	add: #Refactoring -> #asWebsideJson;
	add: #Refactoring -> #fromWebsideJson:;
	add: #Refactoring -> #websideExecute;
	add: #RefactoryChange -> #asWebsideJson;
	add: #RefactoryChange -> #fromWebsideJson:;
	add: #RefactoryChange -> #websideExecute;
	add: #RefactoryClassChange -> #asWebsideJson;
	add: #RefactoryClassChange -> #fromWebsideJson:;
	add: #RefactoryVariableChange -> #asWebsideJson;
	add: #RefactoryVariableChange -> #fromWebsideJson:;
	add: #RemoveMethodChange -> #asWebsideJson;
	add: #RemoveMethodChange -> #fromWebsideJson:;
	add: #RenameClassChange -> #asWebsideJson;
	add: #RenameClassChange -> #fromWebsideJson:;
	add: #RenameMethodRefactoring -> #asWebsideJson;
	add: #RenameMethodRefactoring -> #fromWebsideJson:;
	add: #RenameVariableChange -> #asWebsideJson;
	add: #RenameVariableChange -> #fromWebsideJson:;
	add: #StackFrame -> #asWebsideJson;
	add: #StAssignmentNode -> #asWebsideJson;
	add: #StCascadeNode -> #asWebsideJson;
	add: #StLiteralToken -> #asWebsideJson;
	add: #StLiteralValueNode -> #asWebsideJson;
	add: #StMessageNode -> #asWebsideJson;
	add: #StMethodNode -> #asWebsideJson;
	add: #StProgramNode -> #asWebsideJson;
	add: #StProgramNode -> #websideType;
	add: #StReturnNode -> #asWebsideJson;
	add: #String -> #asURL;
	add: #String -> #includesString:;
	add: #String -> #indexOfString:from:to:;
	add: #StSequenceNode -> #asWebsideJson;
	add: #StVariableNode -> #asWebsideJson;
	add: #Symbol -> #evaluateWith:;
	add: #VariableRefactoring -> #asWebsideJson;
	add: #VariableRefactoring -> #fromWebsideJson:;
	add: 'AddClassChange class' -> #websideType;
	add: 'AddClassVariableChange class' -> #websideType;
	add: 'AddInstanceVariableChange class' -> #websideType;
	add: 'AddMethodChange class' -> #websideType;
	add: 'DolphinAddMethodChange class' -> #websideType;
	add: 'PullUpInstanceVariableRefactoring class' -> #websideType;
	add: 'PushDownInstanceVariableRefactoring class' -> #websideType;
	add: 'Refactoring class' -> #acceptsWebsideJson:;
	add: 'Refactoring class' -> #classForWebsideJson:;
	add: 'Refactoring class' -> #fromWebsideJson:;
	add: 'Refactoring class' -> #websideType;
	add: 'RefactoryChange class' -> #acceptsWebsideJson:;
	add: 'RefactoryChange class' -> #classForWebsideJson:;
	add: 'RefactoryChange class' -> #fromWebsideJson:;
	add: 'RefactoryChange class' -> #websideType;
	add: 'RemoveClassChange class' -> #websideType;
	add: 'RemoveClassVariableChange class' -> #websideType;
	add: 'RemoveInstanceVariableChange class' -> #websideType;
	add: 'RemoveMethodChange class' -> #websideType;
	add: 'RenameClassChange class' -> #websideType;
	add: 'RenameClassVariableChange class' -> #websideType;
	add: 'RenameInstanceVariableChange class' -> #websideType;
	add: 'StProgramNode class' -> #websideType;
	add: 'String class' -> #fromUTF8:;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: #(
	'..\Core\Object Arts\Dolphin\IDE\Base\Development System'
	'..\Core\Object Arts\Dolphin\Base\Dolphin'
	'..\Core\Object Arts\Dolphin\System\Base64\Dolphin Base64'
	'..\DolphinHttpServer\DolphinHttpServer\Dolphin Http Server'
	'..\Core\Object Arts\Dolphin\MVP\Base\Dolphin MVP Base'
	'..\Core\Object Arts\Dolphin\MVP\Icons\Dolphin Text Tile Icons'
	'..\Core\Object Arts\Dolphin\MVP\Gdiplus\Gdiplus'
	'..\Core\Object Arts\Dolphin\ActiveX\COM\OLE COM'
	'..\Core\Contributions\Refactory\Refactoring Browser\Change Objects\RBChangeObjects'
	'..\Core\Contributions\Refactory\Refactoring Browser\Environments\RBEnvironments'
	'..\Core\Contributions\Refactory\Refactoring Browser\Refactorings\RBRefactorings'
	'..\Core\Object Arts\Dolphin\System\Compiler\Smalltalk Parser'
	'..\Core\Contributions\svenc\STON\STON-Core'
	'..\Core\Contributions\Camp Smalltalk\SUnit\SUnit').

package!

"Class Definitions"!

Object subclass: #FakeListPresenter
	instanceVariableNames: 'list selection'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #HttpRequestRouter
	instanceVariableNames: 'routes receiver'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #MatchAlgorithm
	instanceVariableNames: 'string pattern start stop tokens failure ranges'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #MatchToken
	instanceVariableNames: 'string start stop'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #PercentEncoder
	instanceVariableNames: 'reserved'
	classVariableNames: 'Current'
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #StarToken
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: 'current'!

Object subclass: #StringPattern
	instanceVariableNames: 'stream tokens'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #URL
	instanceVariableNames: 'scheme user password host port segments query fragment'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #URLTemplate
	instanceVariableNames: 'raw pattern parameters sample description'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #WebsideAPI
	instanceVariableNames: 'server request'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #WebsideClient
	instanceVariableNames: 'url client'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #WebsideEvaluation
	instanceVariableNames: 'id expression receiver context requestor priority process state result error semaphore'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #WebsideResource
	instanceVariableNames: 'id'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #WebsideServer
	instanceVariableNames: 'server router baseUri port resources'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Exception subclass: #WebsideException
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

RefactoryChange subclass: #RefactoryPackageChange
	instanceVariableNames: 'packageName'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

RefactoryClassChange subclass: #ClassifyMethodChange
	instanceVariableNames: 'selector category'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

RefactoryClassChange subclass: #CommentClassChange
	instanceVariableNames: 'comment'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

RefactoryClassChange subclass: #RefactoryCategoryChange
	instanceVariableNames: 'category'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

RefactoryCategoryChange subclass: #AddCategoryChange
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

RefactoryCategoryChange subclass: #RemoveCategoryChange
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

RefactoryCategoryChange subclass: #RenameCategoryChange
	instanceVariableNames: 'newName'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

RefactoryPackageChange subclass: #AddPackageChange
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

RefactoryPackageChange subclass: #RemovePackageChange
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

RefactoryPackageChange subclass: #RenamePackageChange
	instanceVariableNames: 'newName'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

TestCase subclass: #URLTemplateTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

TestCase subclass: #URLTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

WebsideResource subclass: #WebsideWorkspace
	instanceVariableNames: 'contents bindings name'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Loose Methods"!

!AddClassChange methodsFor!

asWebsideJson
	^super asWebsideJson
		at: 'definition' put: definition;
		yourself!

fromWebsideJson: json
	| superclass msg keywords index instanceVariables classVariables poolDictionaries |
	super fromWebsideJson: json.
	definition := json at: 'definition' ifAbsent: [].
	definition
		ifNil: 
			[superclass := json at: 'superclass' ifAbsent: [].
			superclass
				ifNotNil: 
					[instanceVariables := json at: 'instanceVariables' ifAbsent: [#()].
					classVariables := json at: 'classVariables' ifAbsent: [#()].
					poolDictionaries := json at: 'poolDictionaries' ifAbsent: [#()].
					definition := String streamContents: 
									[:s |
									s
										nextPutAll: superclass;
										nextPutAll: ' subclass: ';
										nextPutAll: className printString;
										nextPutAll: ' instanceVariableNames: '''.
									instanceVariables do: [:n | s nextPutAll: n] separatedBy: [s space].
									s nextPutAll: ''' classVariableNames: '''.
									classVariables do: [:n | s nextPutAll: n] separatedBy: [s space].
									s nextPutAll: ''' poolDictionaries: '''.
									poolDictionaries do: [:n | s nextPutAll: n] separatedBy: [s space].
									s nextPut: $']]].
	className
		ifNil: 
			[msg := SmalltalkParser parseExpression: definition.
			keywords := msg selector keywords collect: [:s | s asString].
			index := keywords indexOf: 'subclass:'
						ifAbsent: [keywords indexOf: 'variableByteSubclass:' ifAbsent: [keywords indexOf: 'variableSubclass:']].
			className := (msg arguments at: index) value asString]!

websideExecute
	| class packageName package |
	super websideExecute.
	class := self changeClass.
	class ifNil: [^self].
	packageName := self propertyAt: #packageName ifAbsent: [^self].
	package := PackageManager current packageNamed: packageName ifNone: [^self].
	package ifNotNil: [package addClass: self changeClass]! !

!AddClassChange categoriesForMethods!
asWebsideJson!public! !
fromWebsideJson:!public! !
websideExecute!public! !
!

!AddClassChange class methodsFor!

websideType
	^'AddClass'! !

!AddClassChange class categoriesForMethods!
websideType!public! !
!

!AddClassVariableChange class methodsFor!

websideType
	^'AddClassVariable'! !

!AddClassVariableChange class categoriesForMethods!
websideType!public! !
!

!AddInstanceVariableChange class methodsFor!

websideType
	^'AddInstanceVariable'! !

!AddInstanceVariableChange class categoriesForMethods!
websideType!public! !
!

!AddMethodChange methodsFor!

asWebsideJson
	| json |
	json := super asWebsideJson.
	source ifNotNil: [:s | json at: 'sourceCode' put: s].
	^json
		at: 'selector' put: self selector;
		at: 'category' put: self protocol;
		yourself!

fromWebsideJson: json
	| category |
	super fromWebsideJson: json.
	selector := json at: 'selector' ifAbsent: [].
	selector ifNotNil: [selector := selector asSymbol].
	source := json at: 'sourceCode' ifAbsent: [].
	category := json at: 'category' ifAbsent: [].
	category ifNil: [category := MethodCategory unclassified asString].
	self protocols: {category asSymbol}! !

!AddMethodChange categoriesForMethods!
asWebsideJson!public! !
fromWebsideJson:!public! !
!

!AddMethodChange class methodsFor!

websideType
	^'AbstractAddMethod'! !

!AddMethodChange class categoriesForMethods!
websideType!instance creation!public! !
!

!Character methodsFor!

isAsterisk
	^code = 42!

isQuestionMark
	^code = 63! !

!Character categoriesForMethods!
isAsterisk!public!testing! !
isQuestionMark!public!testing! !
!

!ClassDescription methodsFor!

asWebsideJson
	| definition |
	definition := self definition copyWithout: 10 asCharacter.
	^super asWebsideJson
		at: 'name' put: self name;
		at: 'definition' put: definition;
		at: 'superclass'
		put: (self superclass ifNotNil: [:c | c name]);
		at: 'comment' put: self comment;
		at: 'variable' put: self isVariable;
		at: 'project' put: (self owningPackage ifNotNil: [:p | p name]);
		yourself! !

!ClassDescription categoriesForMethods!
asWebsideJson!converting!public! !
!

!Collection methodsFor!

anyone
	^self detect: [:one | true] ifNone: []!

gather: aBlock
	^self gather: aBlock in: (OrderedCollection new: self size)
!

gather: aBlock in: collection
	self do: [:each | | things |
		things := aBlock value: each.
		collection addAll: things].
	^collection!

groupBy: aspect
	| answer key copy remove |
	answer := Dictionary new.
	(aspect numArgs = 0 or: [aspect class == BlockClosure and: [aspect numArgs = 1]]) ifTrue: [
		self do: [:each | 
			key := aspect evaluateWith: each.
			(answer at: key ifAbsentPut: [OrderedCollection new]) add: each].
		^answer].
	copy := IdentitySet withAll: self.
	remove := IdentitySet new.
	self do: [:each | 
		copy do: [:e | 
			(aspect value: each value: e) ifTrue: [
				remove add: e.
				(answer at: each ifAbsentPut: [OrderedCollection new]) add: e]].
		copy removeAll: remove.
		remove removeAll].
	^answer! !

!Collection categoriesForMethods!
anyone!adding!public! !
gather:!enumerating!public! !
gather:in:!enumerating!public! !
groupBy:!operations!public! !
!

!CompiledCode methodsFor!

asWebsideJson
	| source package |
	source := self getSource copyWithout: 10 asCharacter.
	package := self owningPackage ifNotNil: [:p | p name].
	^super asWebsideJson
		at: 'selector' put: selector;
		at: 'methodClass' put: methodClass name;
		at: 'source' put: source;
		at: 'author' put: 'Unknown';
		at: 'timestamp' put: nil;
		at: 'package' put: package;
		yourself! !

!CompiledCode categoriesForMethods!
asWebsideJson!public! !
!

!CompiledMethod methodsFor!

asWebsideJson
	| category |
	category := self categories detect: [:c | c isPrivacy not and: [c isVirtual not]] ifNone: [].
	^super asWebsideJson
		at: 'category' put: (category ifNotNil: [:c | c name]);
		at: 'author' put: 'Unknown';
		at: 'timestamp' put: nil;
		at: 'overriding' put: self isOverride;
		at: 'overriden' put: self isOverridden;
		yourself! !

!CompiledMethod categoriesForMethods!
asWebsideJson!converting!public! !
!

!CompilerNotification methodsFor!

asWebsideJson
	| interval json |
	interval := Dictionary new
				at: 'start' put: position;
				at: 'end' put: position;
				yourself.
	json := super asWebsideJson.
	json
		at: 'fullDescription' put: self errorMessage;
		at: 'interval' put: interval.
	^json! !

!CompilerNotification categoriesForMethods!
asWebsideJson!accessing!public! !
!

!Debugger methodsFor!

adaptToWebside
	"Super uggly way to trick the UI-less usage of this object.
	With infinite time, we should have a WebsideDebugger to control the debuggee without have to hack/avoid UI dependency."
	stackPresenter := FakeListPresenter new!

process
	^process!

stepInto: aStackFrame
	"This is a handy service to enable interactions without UI (such as through WebsideAPI).
	Of course #stepInto could (and should) be implemented by calling this method, but we
	decided to preserve original Dolphin services untouched by the moment."

	self debugState: 'Step Into'.
	breakWhen removeAll.
	self stepInFrame: aStackFrame!

stepIntoBlock: aStackFrame
	"This is a handy service to enable interactions without UI (such as through WebsideAPI).
	Of course #stepIntoBlock could (and should) be implemented by calling this method, but we
	decided to preserve original Dolphin services untouched by the moment."

	self debugState: 'Step Into Block'.
	"Break when encountering a block homed in the current method, or when returning to the current frame without encountering one"
	self
		breakWhen: [:f | f index = aStackFrame index or: [f isBlockFrame and: [f method = aStackFrame method]]].
	self runDebuggedProcess!

stepOver: aStackFrame
	"This is a handy service to enable interactions without UI (such as through WebsideAPI).
	Of course #stepOver could (and should) be implemented by calling this method, but we
	decided to preserve original Dolphin services untouched by the moment."

	Transcript cr; nextPutAll: 'Stepping over '.
	self beRunning.
	self debugState: 'Step over'.
	aStackFrame displayOn: Transcript.
	self breakFrame: aStackFrame.
	self makeDebugFrame: aStackFrame sender.
	self resume! !

!Debugger categoriesForMethods!
adaptToWebside!public! !
process!private!updating! !
stepInto:!public! !
stepIntoBlock:!public! !
stepOver:!public! !
!

!DolphinAddMethodChange class methodsFor!

websideType
	^'AddMethod'! !

!DolphinAddMethodChange class categoriesForMethods!
websideType!public! !
!

!Exception methodsFor!

asWebsideJson
	| json |
	json := super asWebsideJson.
	json at: 'description' put: self description.
	^json! !

!Exception categoriesForMethods!
asWebsideJson!handling!public! !
!

!MethodCompileFailed methodsFor!

asWebsideJson
	^compilerErrorNotification asWebsideJson! !

!MethodCompileFailed categoriesForMethods!
asWebsideJson!accessing!private! !
!

!MethodRefactoring methodsFor!

asWebsideJson
	^super asWebsideJson
		at: 'className' put: class name asString;
		yourself!

fromWebsideJson: json
	super fromWebsideJson: json.
	json at: 'className'
		ifPresent: [:n | Smalltalk at: n ifPresent: [:c | class := RBClass existingNamed: n]]! !

!MethodRefactoring categoriesForMethods!
asWebsideJson!private! !
fromWebsideJson:!private! !
!

!Object methodsFor!

asWebsideJson
	| printed |
	printed := [self printString] on: Error
				do: [:e | 'Error while printing ' , self class name , ' instance'].
	^Dictionary new
		at: 'class' put: self class name;
		at: 'hasNamedSlots' put: self class isPointers;
		at: 'hasIndexedSlots' put: self isIndexable;
		at: 'size' put: (self class isVariable ifTrue: [self size] ifFalse: [0]);
		at: 'printString' put: printed;
		at: 'iconName' put: self websideIconName;
		yourself!

websideIconName
	| icon |
	icon := self icon.
	icon ifNil: [^nil].
	icon class == TextTileIcon ifTrue: [^icon text asString].
	^[icon identifier asLowercase] on: Error do: [:e | ]!

websideViews
	^#()! !

!Object categoriesForMethods!
asWebsideJson!converting!public! !
websideIconName!converting!public! !
websideViews!exceptions!private! !
!

!Package methodsFor!

asWebsideJson
	| methods |
	methods := Dictionary new.
	self methodNames
		do: [:a | (methods at: a key asString ifAbsentPut: [OrderedCollection new]) add: a value].
	methods keysAndValuesDo: [:k :v | methods at: k put: v asArray].
	^super asWebsideJson
		at: 'name' put: name;
		at: 'classes' put: self classNames asArray;
		at: 'methods' put: methods;
		yourself! !

!Package categoriesForMethods!
asWebsideJson!converting!private! !
!

!PullUpInstanceVariableRefactoring methodsFor!

fromWebsideJson: json
	super fromWebsideJson: json.
	json at: 'target'
		ifPresent: 
			[:n |
			Smalltalk at: n
				ifPresent: 
					[:c |
					class := RBClass existingNamed: n.
					class model: model]]! !

!PullUpInstanceVariableRefactoring categoriesForMethods!
fromWebsideJson:!public! !
!

!PullUpInstanceVariableRefactoring class methodsFor!

websideType
	^'MoveUpInstanceVariable'! !

!PullUpInstanceVariableRefactoring class categoriesForMethods!
websideType!public! !
!

!PushDownInstanceVariableRefactoring class methodsFor!

websideType
	^'MoveDownInstanceVariable'! !

!PushDownInstanceVariableRefactoring class categoriesForMethods!
websideType!public! !
!

!Refactoring methodsFor!

asWebsideJson
	^Dictionary new
		at: 'type' put: self class websideType;
		at: 'label' put: self class websideType;
		at: 'package' put: (self propertyAt: #packageName ifAbsent: []);
		at: 'timestamp' put: DateAndTime now printString;
		at: 'author' put: nil;
		yourself!

fromWebsideJson: json
	json at: 'package' ifPresent: [:n | self propertyAt: #packageName put: n].
	self model	"Only to initialize it"!

websideExecute
	^self execute! !

!Refactoring categoriesForMethods!
asWebsideJson!public! !
fromWebsideJson:!public! !
websideExecute!public! !
!

!Refactoring class methodsFor!

acceptsWebsideJson: json
	| type |
	type := json at: 'type' ifAbsent: nil.
	^self websideType = type!

classForWebsideJson: json
	^self allSubclasses detect: [:c | c acceptsWebsideJson: json] ifNone: []!

fromWebsideJson: json
	| class |
	class := self classForWebsideJson: json.
	^class ifNotNil: [class new fromWebsideJson: json]!

websideType
	| type |
	type := self name asString.
	(type endsWith: 'Refactoring') ifTrue: [type := type copyFrom: 1 to: type size - 11].
	^type! !

!Refactoring class categoriesForMethods!
acceptsWebsideJson:!class hierarchy-removing!public! !
classForWebsideJson:!class hierarchy-removing!public! !
fromWebsideJson:!class hierarchy-removing!public! !
websideType!class hierarchy-removing!public! !
!

!RefactoryChange methodsFor!

asWebsideJson
	^Dictionary new
		at: 'type' put: self class websideType;
		at: 'label' put: ([self changeString] on: Error do: [:e | self class websideType]);
		at: 'package' put: (self propertyAt: #packageName ifAbsent: []);
		at: 'timestamp' put: DateAndTime now printString;
		at: 'author' put: nil;
		yourself!

fromWebsideJson: json
	json at: 'package' ifPresent: [:n | self propertyAt: #packageName put: n]!

websideExecute
	^self execute! !

!RefactoryChange categoriesForMethods!
asWebsideJson!initialize/release!public! !
fromWebsideJson:!initialize/release!public! !
websideExecute!initialize/release!public! !
!

!RefactoryChange class methodsFor!

acceptsWebsideJson: json
	| type |
	type := json at: 'type' ifAbsent: nil.
	^self websideType = type!

classForWebsideJson: json
	^self allSubclasses detect: [:c | c acceptsWebsideJson: json] ifNone: []!

fromWebsideJson: json
	| class |
	class := self classForWebsideJson: json.
	^class ifNotNil: [class new fromWebsideJson: json]!

websideType
	| type |
	type := self name asString.
	(type endsWith: 'Change') ifTrue: [type := type copyFrom: 1 to: type size - 6].
	^type! !

!RefactoryChange class categoriesForMethods!
acceptsWebsideJson:!public! !
classForWebsideJson:!public! !
fromWebsideJson:!public! !
websideType!public! !
!

!RefactoryClassChange methodsFor!

asWebsideJson
	^super asWebsideJson
		at: 'className' put: self changeClass name asString;
		yourself!

fromWebsideJson: json
	super fromWebsideJson: json.
	className := json at: 'className' ifAbsent: [].
	isMeta := className notNil and: [className endsWith: ' class'].
	(className notNil and: [isMeta])
		ifTrue: [className := (className copyFrom: 1 to: className size - 6) asSymbol]! !

!RefactoryClassChange categoriesForMethods!
asWebsideJson!accessing!public! !
fromWebsideJson:!accessing!public! !
!

!RefactoryVariableChange methodsFor!

asWebsideJson
	^super asWebsideJson at: 'variable' put: variable; yourself!

fromWebsideJson: json
	super fromWebsideJson: json.
	variable := json at: 'variable' ifAbsent: nil! !

!RefactoryVariableChange categoriesForMethods!
asWebsideJson!initialize/release!public! !
fromWebsideJson:!initialize/release!public! !
!

!RemoveClassChange class methodsFor!

websideType
	^'RemoveClass'! !

!RemoveClassChange class categoriesForMethods!
websideType!public! !
!

!RemoveClassVariableChange class methodsFor!

websideType
	^'RemoveClassVariable'! !

!RemoveClassVariableChange class categoriesForMethods!
websideType!public! !
!

!RemoveInstanceVariableChange class methodsFor!

websideType
	^'RemoveInstanceVariable'! !

!RemoveInstanceVariableChange class categoriesForMethods!
websideType!public! !
!

!RemoveMethodChange methodsFor!

asWebsideJson
	^super asWebsideJson at: 'selector' put: selector; yourself!

fromWebsideJson: json
	super fromWebsideJson: json.
	selector := json at: 'selector' ifAbsent: [].
	selector notNil ifTrue: [selector := selector asSymbol]! !

!RemoveMethodChange categoriesForMethods!
asWebsideJson!public! !
fromWebsideJson:!public! !
!

!RemoveMethodChange class methodsFor!

websideType
	^'RemoveMethod'! !

!RemoveMethodChange class categoriesForMethods!
websideType!public! !
!

!RenameClassChange methodsFor!

asWebsideJson
	^super asWebsideJson
		at: 'className' put: oldName;
		at: 'newName' put: newName;
		at: 'renameReferences' put: true;
		yourself!

fromWebsideJson: json
	super fromWebsideJson: json.
	oldName := json at: 'className' ifAbsent: [].
	newName := json at: 'newName' ifAbsent: []! !

!RenameClassChange categoriesForMethods!
asWebsideJson!initialize/release!public! !
fromWebsideJson:!initialize/release!public! !
!

!RenameClassChange class methodsFor!

websideType
	^'RenameClass'! !

!RenameClassChange class categoriesForMethods!
websideType!instance creation!public! !
!

!RenameClassVariableChange class methodsFor!

websideType
	^'RenameClassVariable'! !

!RenameClassVariableChange class categoriesForMethods!
websideType!public! !
!

!RenameInstanceVariableChange class methodsFor!

websideType
	^'RenameInstanceVariable'! !

!RenameInstanceVariableChange class categoriesForMethods!
websideType!public! !
!

!RenameMethodRefactoring methodsFor!

asWebsideJson
	^super asWebsideJson
		at: 'selector' put: oldSelector;
		at: 'newSelector' put: newSelector;
		yourself!

fromWebsideJson: json
	super fromWebsideJson: json.
	json at: 'selector' ifPresent: [:s | oldSelector := s asSymbol].
	json at: 'newSelector'
		ifPresent: 
			[:s |
			newSelector := s asSymbol.
			permutation := 1 to: newSelector argumentCount]! !

!RenameMethodRefactoring categoriesForMethods!
asWebsideJson!public!testing! !
fromWebsideJson:!public!testing! !
!

!RenameVariableChange methodsFor!

asWebsideJson
	^super asWebsideJson
		at: 'className' put: className;
		at: 'variable' put: oldName;
		at: 'newName' put: newName;
		yourself!

fromWebsideJson: json
	super fromWebsideJson: json.
	className := json at: 'className' ifAbsent: [].
	isMeta := className notNil and: [className endsWith: ' class'].
	oldName := json at: 'variable' ifAbsent: [].
	newName := json at: 'newName' ifAbsent: []! !

!RenameVariableChange categoriesForMethods!
asWebsideJson!printing!public! !
fromWebsideJson:!printing!public! !
!

!StackFrame methodsFor!

asWebsideJson
	| label |
	label := String streamContents: [:s | self displayOn: s].
	^Dictionary new
		at: 'label' put: label;
		at: 'class' put: self receiver class asWebsideJson;
		at: 'method' put: self method asWebsideJson;
		yourself! !

!StackFrame categoriesForMethods!
asWebsideJson!accessing!private! !
!

!StAssignmentNode methodsFor!

asWebsideJson 	^super asWebsideJson at: 'children' put: { variable asWebsideJson . value asWebsideJson }! !

!StAssignmentNode categoriesForMethods!
asWebsideJson!accessing!public! !
!

!StCascadeNode methodsFor!

asWebsideJson
	| children |
	children := messages collect: [:n | n asWebsideJson].
	^super asWebsideJson
		at: 'children' put: children asArray;
		yourself! !

!StCascadeNode categoriesForMethods!
asWebsideJson!public!visitor! !
!

!StLiteralToken methodsFor!

asWebsideJson
	^value asString! !

!StLiteralToken categoriesForMethods!
asWebsideJson!printing!public! !
!

!StLiteralValueNode methodsFor!

asWebsideJson
	| value |
	value := token value isString ifTrue: [token value] ifFalse: [token printString].
	^super asWebsideJson
		at: 'value' put: value;
		yourself! !

!StLiteralValueNode categoriesForMethods!
asWebsideJson!matching!public! !
!

!StMessageNode methodsFor!

asWebsideJson
	| s children |
	s := Dictionary new
				at: 'type' put: 'Selector';
				at: 'value' put: self selector;
				at: 'start' put: selectorParts first start;
				at: 'stop' put: selectorParts last stop;
				yourself.
	children := OrderedCollection with: receiver asWebsideJson with: s.
	arguments do: [:n | children add: n asWebsideJson].
	^super asWebsideJson
		at: 'children' put: children asArray;
		yourself! !

!StMessageNode categoriesForMethods!
asWebsideJson!matching!public! !
!

!StMethodNode methodsFor!

asWebsideJson	| children |	children := OrderedCollection with: self selector asWebsideJson.	arguments do: [ :n | children add: n asWebsideJson  ].	children add: body asWebsideJson .	^super asWebsideJson at: 'children' put: children asArray; yourself ! !

!StMethodNode categoriesForMethods!
asWebsideJson!public!visitor! !
!

!StProgramNode methodsFor!

asWebsideJson	^ super asWebsideJson		at: 'type' put: self websideType;		at: 'start' put: self start;		at: 'end' put: self stop;		yourself!

websideType	^self class websideType! !

!StProgramNode categoriesForMethods!
asWebsideJson!public!replacing! !
websideType!public!replacing! !
!

!StProgramNode class methodsFor!

websideType	^self name copyFrom: 3 to: self name size - 4! !

!StProgramNode class categoriesForMethods!
websideType!constants!public! !
!

!StReturnNode methodsFor!

asWebsideJson 	^super asWebsideJson at: 'children' put: { value asWebsideJson  }; yourself! !

!StReturnNode categoriesForMethods!
asWebsideJson!public!visitor! !
!

!String methodsFor!

asURL
	^URL fromString: self trimBlanks!

includesString: aString
	^(self indexOfSubCollection: aString) > 0!

indexOfString: aString from: start to: stop
	| n limit base i |
	n := aString size.
	limit := stop - n.
	base := start - 1.
	i := 1.
	[
		base > limit ifTrue: [^0].
		i <= n]
		whileTrue: [
			i := (self at: base + i) = (aString at: i) ifTrue: [i + 1] ifFalse: [
				base := base + 1.
				1]].
	^i > 1 ifTrue: [base + 1] ifFalse: [0]

! !

!String categoriesForMethods!
asURL!converting!public! !
includesString:!comparing!public! !
indexOfString:from:to:!comparing!public! !
!

!String class methodsFor!

fromUTF8: aString
	^(aString anySatisfy: [:byte | byte asInteger >= 128])
		ifTrue: [aString asUtf8String]
		ifFalse: [aString]! !

!String class categoriesForMethods!
fromUTF8:!instance creation!public! !
!

!StSequenceNode methodsFor!

asWebsideJson 	| children |	children := OrderedCollection new.	temporaries do: [ :n | children add: n asWebsideJson  ].	statements do: [ :n |  children add: n asWebsideJson].	^super asWebsideJson at: 'children' put: children asArray ; yourself! !

!StSequenceNode categoriesForMethods!
asWebsideJson!public!visitor! !
!

!StVariableNode methodsFor!

asWebsideJson	^ super asWebsideJson		at: 'value' put: name;		yourself! !

!StVariableNode categoriesForMethods!
asWebsideJson!public!visitor! !
!

!Symbol methodsFor!

evaluateWith: anObject
	^anObject perform: self! !

!Symbol categoriesForMethods!
evaluateWith:!converting!public! !
!

!VariableRefactoring methodsFor!

asWebsideJson
	^super asWebsideJson
		at: 'className' put: class name asString;
		at: 'variable' put: variableName;
		yourself!

fromWebsideJson: json
	super fromWebsideJson: json.
	json at: 'className'
		ifPresent: 
			[:n |
			Smalltalk at: n
				ifPresent: 
					[:c |
					class := RBClass existingNamed: n.
					class model: model]].
	variableName := json at: 'variable' ifAbsent: []! !

!VariableRefactoring categoriesForMethods!
asWebsideJson!initialize/release!public! !
fromWebsideJson:!initialize/release!public! !
!

"End of package definition"!

